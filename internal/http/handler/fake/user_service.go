// Code generated by counterfeiter. DO NOT EDIT.
package fake

import (
	"context"
	"io"
	"sync"

	"github.com/dgdraganov/user-api/internal/http/handler"
	"github.com/dgdraganov/user-api/internal/service"
	"github.com/golang-jwt/jwt"
)

type UserService struct {
	AuthenticateStub        func(context.Context, service.AuthMessage) (string, error)
	authenticateMutex       sync.RWMutex
	authenticateArgsForCall []struct {
		arg1 context.Context
		arg2 service.AuthMessage
	}
	authenticateReturns struct {
		result1 string
		result2 error
	}
	authenticateReturnsOnCall map[int]struct {
		result1 string
		result2 error
	}
	DeleteUserStub        func(context.Context, string) error
	deleteUserMutex       sync.RWMutex
	deleteUserArgsForCall []struct {
		arg1 context.Context
		arg2 string
	}
	deleteUserReturns struct {
		result1 error
	}
	deleteUserReturnsOnCall map[int]struct {
		result1 error
	}
	DeleteUserFilesStub        func(context.Context, string) error
	deleteUserFilesMutex       sync.RWMutex
	deleteUserFilesArgsForCall []struct {
		arg1 context.Context
		arg2 string
	}
	deleteUserFilesReturns struct {
		result1 error
	}
	deleteUserFilesReturnsOnCall map[int]struct {
		result1 error
	}
	GetUserStub        func(context.Context, string) (service.UserRecord, error)
	getUserMutex       sync.RWMutex
	getUserArgsForCall []struct {
		arg1 context.Context
		arg2 string
	}
	getUserReturns struct {
		result1 service.UserRecord
		result2 error
	}
	getUserReturnsOnCall map[int]struct {
		result1 service.UserRecord
		result2 error
	}
	ListUserFilesStub        func(context.Context, string) ([]service.FileRecord, error)
	listUserFilesMutex       sync.RWMutex
	listUserFilesArgsForCall []struct {
		arg1 context.Context
		arg2 string
	}
	listUserFilesReturns struct {
		result1 []service.FileRecord
		result2 error
	}
	listUserFilesReturnsOnCall map[int]struct {
		result1 []service.FileRecord
		result2 error
	}
	ListUsersStub        func(context.Context, int, int) ([]service.UserRecord, error)
	listUsersMutex       sync.RWMutex
	listUsersArgsForCall []struct {
		arg1 context.Context
		arg2 int
		arg3 int
	}
	listUsersReturns struct {
		result1 []service.UserRecord
		result2 error
	}
	listUsersReturnsOnCall map[int]struct {
		result1 []service.UserRecord
		result2 error
	}
	PublishEventStub        func(context.Context, string, interface{}) error
	publishEventMutex       sync.RWMutex
	publishEventArgsForCall []struct {
		arg1 context.Context
		arg2 string
		arg3 interface{}
	}
	publishEventReturns struct {
		result1 error
	}
	publishEventReturnsOnCall map[int]struct {
		result1 error
	}
	RegisterUserStub        func(context.Context, service.RegisterMessage) error
	registerUserMutex       sync.RWMutex
	registerUserArgsForCall []struct {
		arg1 context.Context
		arg2 service.RegisterMessage
	}
	registerUserReturns struct {
		result1 error
	}
	registerUserReturnsOnCall map[int]struct {
		result1 error
	}
	SaveFileMetadataStub        func(context.Context, string, string, string) error
	saveFileMetadataMutex       sync.RWMutex
	saveFileMetadataArgsForCall []struct {
		arg1 context.Context
		arg2 string
		arg3 string
		arg4 string
	}
	saveFileMetadataReturns struct {
		result1 error
	}
	saveFileMetadataReturnsOnCall map[int]struct {
		result1 error
	}
	UpdateUserStub        func(context.Context, service.UpdateUserMessage, string) error
	updateUserMutex       sync.RWMutex
	updateUserArgsForCall []struct {
		arg1 context.Context
		arg2 service.UpdateUserMessage
		arg3 string
	}
	updateUserReturns struct {
		result1 error
	}
	updateUserReturnsOnCall map[int]struct {
		result1 error
	}
	UploadUserFileStub        func(context.Context, string, io.Reader, int64) error
	uploadUserFileMutex       sync.RWMutex
	uploadUserFileArgsForCall []struct {
		arg1 context.Context
		arg2 string
		arg3 io.Reader
		arg4 int64
	}
	uploadUserFileReturns struct {
		result1 error
	}
	uploadUserFileReturnsOnCall map[int]struct {
		result1 error
	}
	ValidateTokenStub        func(context.Context, string) (jwt.MapClaims, error)
	validateTokenMutex       sync.RWMutex
	validateTokenArgsForCall []struct {
		arg1 context.Context
		arg2 string
	}
	validateTokenReturns struct {
		result1 jwt.MapClaims
		result2 error
	}
	validateTokenReturnsOnCall map[int]struct {
		result1 jwt.MapClaims
		result2 error
	}
	invocations      map[string][][]interface{}
	invocationsMutex sync.RWMutex
}

func (fake *UserService) Authenticate(arg1 context.Context, arg2 service.AuthMessage) (string, error) {
	fake.authenticateMutex.Lock()
	ret, specificReturn := fake.authenticateReturnsOnCall[len(fake.authenticateArgsForCall)]
	fake.authenticateArgsForCall = append(fake.authenticateArgsForCall, struct {
		arg1 context.Context
		arg2 service.AuthMessage
	}{arg1, arg2})
	stub := fake.AuthenticateStub
	fakeReturns := fake.authenticateReturns
	fake.recordInvocation("Authenticate", []interface{}{arg1, arg2})
	fake.authenticateMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *UserService) AuthenticateCallCount() int {
	fake.authenticateMutex.RLock()
	defer fake.authenticateMutex.RUnlock()
	return len(fake.authenticateArgsForCall)
}

func (fake *UserService) AuthenticateCalls(stub func(context.Context, service.AuthMessage) (string, error)) {
	fake.authenticateMutex.Lock()
	defer fake.authenticateMutex.Unlock()
	fake.AuthenticateStub = stub
}

func (fake *UserService) AuthenticateArgsForCall(i int) (context.Context, service.AuthMessage) {
	fake.authenticateMutex.RLock()
	defer fake.authenticateMutex.RUnlock()
	argsForCall := fake.authenticateArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *UserService) AuthenticateReturns(result1 string, result2 error) {
	fake.authenticateMutex.Lock()
	defer fake.authenticateMutex.Unlock()
	fake.AuthenticateStub = nil
	fake.authenticateReturns = struct {
		result1 string
		result2 error
	}{result1, result2}
}

func (fake *UserService) AuthenticateReturnsOnCall(i int, result1 string, result2 error) {
	fake.authenticateMutex.Lock()
	defer fake.authenticateMutex.Unlock()
	fake.AuthenticateStub = nil
	if fake.authenticateReturnsOnCall == nil {
		fake.authenticateReturnsOnCall = make(map[int]struct {
			result1 string
			result2 error
		})
	}
	fake.authenticateReturnsOnCall[i] = struct {
		result1 string
		result2 error
	}{result1, result2}
}

func (fake *UserService) DeleteUser(arg1 context.Context, arg2 string) error {
	fake.deleteUserMutex.Lock()
	ret, specificReturn := fake.deleteUserReturnsOnCall[len(fake.deleteUserArgsForCall)]
	fake.deleteUserArgsForCall = append(fake.deleteUserArgsForCall, struct {
		arg1 context.Context
		arg2 string
	}{arg1, arg2})
	stub := fake.DeleteUserStub
	fakeReturns := fake.deleteUserReturns
	fake.recordInvocation("DeleteUser", []interface{}{arg1, arg2})
	fake.deleteUserMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *UserService) DeleteUserCallCount() int {
	fake.deleteUserMutex.RLock()
	defer fake.deleteUserMutex.RUnlock()
	return len(fake.deleteUserArgsForCall)
}

func (fake *UserService) DeleteUserCalls(stub func(context.Context, string) error) {
	fake.deleteUserMutex.Lock()
	defer fake.deleteUserMutex.Unlock()
	fake.DeleteUserStub = stub
}

func (fake *UserService) DeleteUserArgsForCall(i int) (context.Context, string) {
	fake.deleteUserMutex.RLock()
	defer fake.deleteUserMutex.RUnlock()
	argsForCall := fake.deleteUserArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *UserService) DeleteUserReturns(result1 error) {
	fake.deleteUserMutex.Lock()
	defer fake.deleteUserMutex.Unlock()
	fake.DeleteUserStub = nil
	fake.deleteUserReturns = struct {
		result1 error
	}{result1}
}

func (fake *UserService) DeleteUserReturnsOnCall(i int, result1 error) {
	fake.deleteUserMutex.Lock()
	defer fake.deleteUserMutex.Unlock()
	fake.DeleteUserStub = nil
	if fake.deleteUserReturnsOnCall == nil {
		fake.deleteUserReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.deleteUserReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *UserService) DeleteUserFiles(arg1 context.Context, arg2 string) error {
	fake.deleteUserFilesMutex.Lock()
	ret, specificReturn := fake.deleteUserFilesReturnsOnCall[len(fake.deleteUserFilesArgsForCall)]
	fake.deleteUserFilesArgsForCall = append(fake.deleteUserFilesArgsForCall, struct {
		arg1 context.Context
		arg2 string
	}{arg1, arg2})
	stub := fake.DeleteUserFilesStub
	fakeReturns := fake.deleteUserFilesReturns
	fake.recordInvocation("DeleteUserFiles", []interface{}{arg1, arg2})
	fake.deleteUserFilesMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *UserService) DeleteUserFilesCallCount() int {
	fake.deleteUserFilesMutex.RLock()
	defer fake.deleteUserFilesMutex.RUnlock()
	return len(fake.deleteUserFilesArgsForCall)
}

func (fake *UserService) DeleteUserFilesCalls(stub func(context.Context, string) error) {
	fake.deleteUserFilesMutex.Lock()
	defer fake.deleteUserFilesMutex.Unlock()
	fake.DeleteUserFilesStub = stub
}

func (fake *UserService) DeleteUserFilesArgsForCall(i int) (context.Context, string) {
	fake.deleteUserFilesMutex.RLock()
	defer fake.deleteUserFilesMutex.RUnlock()
	argsForCall := fake.deleteUserFilesArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *UserService) DeleteUserFilesReturns(result1 error) {
	fake.deleteUserFilesMutex.Lock()
	defer fake.deleteUserFilesMutex.Unlock()
	fake.DeleteUserFilesStub = nil
	fake.deleteUserFilesReturns = struct {
		result1 error
	}{result1}
}

func (fake *UserService) DeleteUserFilesReturnsOnCall(i int, result1 error) {
	fake.deleteUserFilesMutex.Lock()
	defer fake.deleteUserFilesMutex.Unlock()
	fake.DeleteUserFilesStub = nil
	if fake.deleteUserFilesReturnsOnCall == nil {
		fake.deleteUserFilesReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.deleteUserFilesReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *UserService) GetUser(arg1 context.Context, arg2 string) (service.UserRecord, error) {
	fake.getUserMutex.Lock()
	ret, specificReturn := fake.getUserReturnsOnCall[len(fake.getUserArgsForCall)]
	fake.getUserArgsForCall = append(fake.getUserArgsForCall, struct {
		arg1 context.Context
		arg2 string
	}{arg1, arg2})
	stub := fake.GetUserStub
	fakeReturns := fake.getUserReturns
	fake.recordInvocation("GetUser", []interface{}{arg1, arg2})
	fake.getUserMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *UserService) GetUserCallCount() int {
	fake.getUserMutex.RLock()
	defer fake.getUserMutex.RUnlock()
	return len(fake.getUserArgsForCall)
}

func (fake *UserService) GetUserCalls(stub func(context.Context, string) (service.UserRecord, error)) {
	fake.getUserMutex.Lock()
	defer fake.getUserMutex.Unlock()
	fake.GetUserStub = stub
}

func (fake *UserService) GetUserArgsForCall(i int) (context.Context, string) {
	fake.getUserMutex.RLock()
	defer fake.getUserMutex.RUnlock()
	argsForCall := fake.getUserArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *UserService) GetUserReturns(result1 service.UserRecord, result2 error) {
	fake.getUserMutex.Lock()
	defer fake.getUserMutex.Unlock()
	fake.GetUserStub = nil
	fake.getUserReturns = struct {
		result1 service.UserRecord
		result2 error
	}{result1, result2}
}

func (fake *UserService) GetUserReturnsOnCall(i int, result1 service.UserRecord, result2 error) {
	fake.getUserMutex.Lock()
	defer fake.getUserMutex.Unlock()
	fake.GetUserStub = nil
	if fake.getUserReturnsOnCall == nil {
		fake.getUserReturnsOnCall = make(map[int]struct {
			result1 service.UserRecord
			result2 error
		})
	}
	fake.getUserReturnsOnCall[i] = struct {
		result1 service.UserRecord
		result2 error
	}{result1, result2}
}

func (fake *UserService) ListUserFiles(arg1 context.Context, arg2 string) ([]service.FileRecord, error) {
	fake.listUserFilesMutex.Lock()
	ret, specificReturn := fake.listUserFilesReturnsOnCall[len(fake.listUserFilesArgsForCall)]
	fake.listUserFilesArgsForCall = append(fake.listUserFilesArgsForCall, struct {
		arg1 context.Context
		arg2 string
	}{arg1, arg2})
	stub := fake.ListUserFilesStub
	fakeReturns := fake.listUserFilesReturns
	fake.recordInvocation("ListUserFiles", []interface{}{arg1, arg2})
	fake.listUserFilesMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *UserService) ListUserFilesCallCount() int {
	fake.listUserFilesMutex.RLock()
	defer fake.listUserFilesMutex.RUnlock()
	return len(fake.listUserFilesArgsForCall)
}

func (fake *UserService) ListUserFilesCalls(stub func(context.Context, string) ([]service.FileRecord, error)) {
	fake.listUserFilesMutex.Lock()
	defer fake.listUserFilesMutex.Unlock()
	fake.ListUserFilesStub = stub
}

func (fake *UserService) ListUserFilesArgsForCall(i int) (context.Context, string) {
	fake.listUserFilesMutex.RLock()
	defer fake.listUserFilesMutex.RUnlock()
	argsForCall := fake.listUserFilesArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *UserService) ListUserFilesReturns(result1 []service.FileRecord, result2 error) {
	fake.listUserFilesMutex.Lock()
	defer fake.listUserFilesMutex.Unlock()
	fake.ListUserFilesStub = nil
	fake.listUserFilesReturns = struct {
		result1 []service.FileRecord
		result2 error
	}{result1, result2}
}

func (fake *UserService) ListUserFilesReturnsOnCall(i int, result1 []service.FileRecord, result2 error) {
	fake.listUserFilesMutex.Lock()
	defer fake.listUserFilesMutex.Unlock()
	fake.ListUserFilesStub = nil
	if fake.listUserFilesReturnsOnCall == nil {
		fake.listUserFilesReturnsOnCall = make(map[int]struct {
			result1 []service.FileRecord
			result2 error
		})
	}
	fake.listUserFilesReturnsOnCall[i] = struct {
		result1 []service.FileRecord
		result2 error
	}{result1, result2}
}

func (fake *UserService) ListUsers(arg1 context.Context, arg2 int, arg3 int) ([]service.UserRecord, error) {
	fake.listUsersMutex.Lock()
	ret, specificReturn := fake.listUsersReturnsOnCall[len(fake.listUsersArgsForCall)]
	fake.listUsersArgsForCall = append(fake.listUsersArgsForCall, struct {
		arg1 context.Context
		arg2 int
		arg3 int
	}{arg1, arg2, arg3})
	stub := fake.ListUsersStub
	fakeReturns := fake.listUsersReturns
	fake.recordInvocation("ListUsers", []interface{}{arg1, arg2, arg3})
	fake.listUsersMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *UserService) ListUsersCallCount() int {
	fake.listUsersMutex.RLock()
	defer fake.listUsersMutex.RUnlock()
	return len(fake.listUsersArgsForCall)
}

func (fake *UserService) ListUsersCalls(stub func(context.Context, int, int) ([]service.UserRecord, error)) {
	fake.listUsersMutex.Lock()
	defer fake.listUsersMutex.Unlock()
	fake.ListUsersStub = stub
}

func (fake *UserService) ListUsersArgsForCall(i int) (context.Context, int, int) {
	fake.listUsersMutex.RLock()
	defer fake.listUsersMutex.RUnlock()
	argsForCall := fake.listUsersArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *UserService) ListUsersReturns(result1 []service.UserRecord, result2 error) {
	fake.listUsersMutex.Lock()
	defer fake.listUsersMutex.Unlock()
	fake.ListUsersStub = nil
	fake.listUsersReturns = struct {
		result1 []service.UserRecord
		result2 error
	}{result1, result2}
}

func (fake *UserService) ListUsersReturnsOnCall(i int, result1 []service.UserRecord, result2 error) {
	fake.listUsersMutex.Lock()
	defer fake.listUsersMutex.Unlock()
	fake.ListUsersStub = nil
	if fake.listUsersReturnsOnCall == nil {
		fake.listUsersReturnsOnCall = make(map[int]struct {
			result1 []service.UserRecord
			result2 error
		})
	}
	fake.listUsersReturnsOnCall[i] = struct {
		result1 []service.UserRecord
		result2 error
	}{result1, result2}
}

func (fake *UserService) PublishEvent(arg1 context.Context, arg2 string, arg3 interface{}) error {
	fake.publishEventMutex.Lock()
	ret, specificReturn := fake.publishEventReturnsOnCall[len(fake.publishEventArgsForCall)]
	fake.publishEventArgsForCall = append(fake.publishEventArgsForCall, struct {
		arg1 context.Context
		arg2 string
		arg3 interface{}
	}{arg1, arg2, arg3})
	stub := fake.PublishEventStub
	fakeReturns := fake.publishEventReturns
	fake.recordInvocation("PublishEvent", []interface{}{arg1, arg2, arg3})
	fake.publishEventMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *UserService) PublishEventCallCount() int {
	fake.publishEventMutex.RLock()
	defer fake.publishEventMutex.RUnlock()
	return len(fake.publishEventArgsForCall)
}

func (fake *UserService) PublishEventCalls(stub func(context.Context, string, interface{}) error) {
	fake.publishEventMutex.Lock()
	defer fake.publishEventMutex.Unlock()
	fake.PublishEventStub = stub
}

func (fake *UserService) PublishEventArgsForCall(i int) (context.Context, string, interface{}) {
	fake.publishEventMutex.RLock()
	defer fake.publishEventMutex.RUnlock()
	argsForCall := fake.publishEventArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *UserService) PublishEventReturns(result1 error) {
	fake.publishEventMutex.Lock()
	defer fake.publishEventMutex.Unlock()
	fake.PublishEventStub = nil
	fake.publishEventReturns = struct {
		result1 error
	}{result1}
}

func (fake *UserService) PublishEventReturnsOnCall(i int, result1 error) {
	fake.publishEventMutex.Lock()
	defer fake.publishEventMutex.Unlock()
	fake.PublishEventStub = nil
	if fake.publishEventReturnsOnCall == nil {
		fake.publishEventReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.publishEventReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *UserService) RegisterUser(arg1 context.Context, arg2 service.RegisterMessage) error {
	fake.registerUserMutex.Lock()
	ret, specificReturn := fake.registerUserReturnsOnCall[len(fake.registerUserArgsForCall)]
	fake.registerUserArgsForCall = append(fake.registerUserArgsForCall, struct {
		arg1 context.Context
		arg2 service.RegisterMessage
	}{arg1, arg2})
	stub := fake.RegisterUserStub
	fakeReturns := fake.registerUserReturns
	fake.recordInvocation("RegisterUser", []interface{}{arg1, arg2})
	fake.registerUserMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *UserService) RegisterUserCallCount() int {
	fake.registerUserMutex.RLock()
	defer fake.registerUserMutex.RUnlock()
	return len(fake.registerUserArgsForCall)
}

func (fake *UserService) RegisterUserCalls(stub func(context.Context, service.RegisterMessage) error) {
	fake.registerUserMutex.Lock()
	defer fake.registerUserMutex.Unlock()
	fake.RegisterUserStub = stub
}

func (fake *UserService) RegisterUserArgsForCall(i int) (context.Context, service.RegisterMessage) {
	fake.registerUserMutex.RLock()
	defer fake.registerUserMutex.RUnlock()
	argsForCall := fake.registerUserArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *UserService) RegisterUserReturns(result1 error) {
	fake.registerUserMutex.Lock()
	defer fake.registerUserMutex.Unlock()
	fake.RegisterUserStub = nil
	fake.registerUserReturns = struct {
		result1 error
	}{result1}
}

func (fake *UserService) RegisterUserReturnsOnCall(i int, result1 error) {
	fake.registerUserMutex.Lock()
	defer fake.registerUserMutex.Unlock()
	fake.RegisterUserStub = nil
	if fake.registerUserReturnsOnCall == nil {
		fake.registerUserReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.registerUserReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *UserService) SaveFileMetadata(arg1 context.Context, arg2 string, arg3 string, arg4 string) error {
	fake.saveFileMetadataMutex.Lock()
	ret, specificReturn := fake.saveFileMetadataReturnsOnCall[len(fake.saveFileMetadataArgsForCall)]
	fake.saveFileMetadataArgsForCall = append(fake.saveFileMetadataArgsForCall, struct {
		arg1 context.Context
		arg2 string
		arg3 string
		arg4 string
	}{arg1, arg2, arg3, arg4})
	stub := fake.SaveFileMetadataStub
	fakeReturns := fake.saveFileMetadataReturns
	fake.recordInvocation("SaveFileMetadata", []interface{}{arg1, arg2, arg3, arg4})
	fake.saveFileMetadataMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3, arg4)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *UserService) SaveFileMetadataCallCount() int {
	fake.saveFileMetadataMutex.RLock()
	defer fake.saveFileMetadataMutex.RUnlock()
	return len(fake.saveFileMetadataArgsForCall)
}

func (fake *UserService) SaveFileMetadataCalls(stub func(context.Context, string, string, string) error) {
	fake.saveFileMetadataMutex.Lock()
	defer fake.saveFileMetadataMutex.Unlock()
	fake.SaveFileMetadataStub = stub
}

func (fake *UserService) SaveFileMetadataArgsForCall(i int) (context.Context, string, string, string) {
	fake.saveFileMetadataMutex.RLock()
	defer fake.saveFileMetadataMutex.RUnlock()
	argsForCall := fake.saveFileMetadataArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3, argsForCall.arg4
}

func (fake *UserService) SaveFileMetadataReturns(result1 error) {
	fake.saveFileMetadataMutex.Lock()
	defer fake.saveFileMetadataMutex.Unlock()
	fake.SaveFileMetadataStub = nil
	fake.saveFileMetadataReturns = struct {
		result1 error
	}{result1}
}

func (fake *UserService) SaveFileMetadataReturnsOnCall(i int, result1 error) {
	fake.saveFileMetadataMutex.Lock()
	defer fake.saveFileMetadataMutex.Unlock()
	fake.SaveFileMetadataStub = nil
	if fake.saveFileMetadataReturnsOnCall == nil {
		fake.saveFileMetadataReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.saveFileMetadataReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *UserService) UpdateUser(arg1 context.Context, arg2 service.UpdateUserMessage, arg3 string) error {
	fake.updateUserMutex.Lock()
	ret, specificReturn := fake.updateUserReturnsOnCall[len(fake.updateUserArgsForCall)]
	fake.updateUserArgsForCall = append(fake.updateUserArgsForCall, struct {
		arg1 context.Context
		arg2 service.UpdateUserMessage
		arg3 string
	}{arg1, arg2, arg3})
	stub := fake.UpdateUserStub
	fakeReturns := fake.updateUserReturns
	fake.recordInvocation("UpdateUser", []interface{}{arg1, arg2, arg3})
	fake.updateUserMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *UserService) UpdateUserCallCount() int {
	fake.updateUserMutex.RLock()
	defer fake.updateUserMutex.RUnlock()
	return len(fake.updateUserArgsForCall)
}

func (fake *UserService) UpdateUserCalls(stub func(context.Context, service.UpdateUserMessage, string) error) {
	fake.updateUserMutex.Lock()
	defer fake.updateUserMutex.Unlock()
	fake.UpdateUserStub = stub
}

func (fake *UserService) UpdateUserArgsForCall(i int) (context.Context, service.UpdateUserMessage, string) {
	fake.updateUserMutex.RLock()
	defer fake.updateUserMutex.RUnlock()
	argsForCall := fake.updateUserArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *UserService) UpdateUserReturns(result1 error) {
	fake.updateUserMutex.Lock()
	defer fake.updateUserMutex.Unlock()
	fake.UpdateUserStub = nil
	fake.updateUserReturns = struct {
		result1 error
	}{result1}
}

func (fake *UserService) UpdateUserReturnsOnCall(i int, result1 error) {
	fake.updateUserMutex.Lock()
	defer fake.updateUserMutex.Unlock()
	fake.UpdateUserStub = nil
	if fake.updateUserReturnsOnCall == nil {
		fake.updateUserReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.updateUserReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *UserService) UploadUserFile(arg1 context.Context, arg2 string, arg3 io.Reader, arg4 int64) error {
	fake.uploadUserFileMutex.Lock()
	ret, specificReturn := fake.uploadUserFileReturnsOnCall[len(fake.uploadUserFileArgsForCall)]
	fake.uploadUserFileArgsForCall = append(fake.uploadUserFileArgsForCall, struct {
		arg1 context.Context
		arg2 string
		arg3 io.Reader
		arg4 int64
	}{arg1, arg2, arg3, arg4})
	stub := fake.UploadUserFileStub
	fakeReturns := fake.uploadUserFileReturns
	fake.recordInvocation("UploadUserFile", []interface{}{arg1, arg2, arg3, arg4})
	fake.uploadUserFileMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3, arg4)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *UserService) UploadUserFileCallCount() int {
	fake.uploadUserFileMutex.RLock()
	defer fake.uploadUserFileMutex.RUnlock()
	return len(fake.uploadUserFileArgsForCall)
}

func (fake *UserService) UploadUserFileCalls(stub func(context.Context, string, io.Reader, int64) error) {
	fake.uploadUserFileMutex.Lock()
	defer fake.uploadUserFileMutex.Unlock()
	fake.UploadUserFileStub = stub
}

func (fake *UserService) UploadUserFileArgsForCall(i int) (context.Context, string, io.Reader, int64) {
	fake.uploadUserFileMutex.RLock()
	defer fake.uploadUserFileMutex.RUnlock()
	argsForCall := fake.uploadUserFileArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3, argsForCall.arg4
}

func (fake *UserService) UploadUserFileReturns(result1 error) {
	fake.uploadUserFileMutex.Lock()
	defer fake.uploadUserFileMutex.Unlock()
	fake.UploadUserFileStub = nil
	fake.uploadUserFileReturns = struct {
		result1 error
	}{result1}
}

func (fake *UserService) UploadUserFileReturnsOnCall(i int, result1 error) {
	fake.uploadUserFileMutex.Lock()
	defer fake.uploadUserFileMutex.Unlock()
	fake.UploadUserFileStub = nil
	if fake.uploadUserFileReturnsOnCall == nil {
		fake.uploadUserFileReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.uploadUserFileReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *UserService) ValidateToken(arg1 context.Context, arg2 string) (jwt.MapClaims, error) {
	fake.validateTokenMutex.Lock()
	ret, specificReturn := fake.validateTokenReturnsOnCall[len(fake.validateTokenArgsForCall)]
	fake.validateTokenArgsForCall = append(fake.validateTokenArgsForCall, struct {
		arg1 context.Context
		arg2 string
	}{arg1, arg2})
	stub := fake.ValidateTokenStub
	fakeReturns := fake.validateTokenReturns
	fake.recordInvocation("ValidateToken", []interface{}{arg1, arg2})
	fake.validateTokenMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *UserService) ValidateTokenCallCount() int {
	fake.validateTokenMutex.RLock()
	defer fake.validateTokenMutex.RUnlock()
	return len(fake.validateTokenArgsForCall)
}

func (fake *UserService) ValidateTokenCalls(stub func(context.Context, string) (jwt.MapClaims, error)) {
	fake.validateTokenMutex.Lock()
	defer fake.validateTokenMutex.Unlock()
	fake.ValidateTokenStub = stub
}

func (fake *UserService) ValidateTokenArgsForCall(i int) (context.Context, string) {
	fake.validateTokenMutex.RLock()
	defer fake.validateTokenMutex.RUnlock()
	argsForCall := fake.validateTokenArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *UserService) ValidateTokenReturns(result1 jwt.MapClaims, result2 error) {
	fake.validateTokenMutex.Lock()
	defer fake.validateTokenMutex.Unlock()
	fake.ValidateTokenStub = nil
	fake.validateTokenReturns = struct {
		result1 jwt.MapClaims
		result2 error
	}{result1, result2}
}

func (fake *UserService) ValidateTokenReturnsOnCall(i int, result1 jwt.MapClaims, result2 error) {
	fake.validateTokenMutex.Lock()
	defer fake.validateTokenMutex.Unlock()
	fake.ValidateTokenStub = nil
	if fake.validateTokenReturnsOnCall == nil {
		fake.validateTokenReturnsOnCall = make(map[int]struct {
			result1 jwt.MapClaims
			result2 error
		})
	}
	fake.validateTokenReturnsOnCall[i] = struct {
		result1 jwt.MapClaims
		result2 error
	}{result1, result2}
}

func (fake *UserService) Invocations() map[string][][]interface{} {
	fake.invocationsMutex.RLock()
	defer fake.invocationsMutex.RUnlock()
	copiedInvocations := map[string][][]interface{}{}
	for key, value := range fake.invocations {
		copiedInvocations[key] = value
	}
	return copiedInvocations
}

func (fake *UserService) recordInvocation(key string, args []interface{}) {
	fake.invocationsMutex.Lock()
	defer fake.invocationsMutex.Unlock()
	if fake.invocations == nil {
		fake.invocations = map[string][][]interface{}{}
	}
	if fake.invocations[key] == nil {
		fake.invocations[key] = [][]interface{}{}
	}
	fake.invocations[key] = append(fake.invocations[key], args)
}

var _ handler.UserService = new(UserService)
